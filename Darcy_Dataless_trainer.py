import numpy as np
import fenics as fe
import torch
import torch.nn as nn
import torch.optim as optim
import os
import pandas as pd
from dataclasses import dataclass, field

# Given a triplet [eig_1,eig_2,theta] the factory class
# trains a pair of darcy nets u,p solving
#       div u = f
#    A grad p = u
#           p = 0  b.c.
# with A sym. pos. def. with eigen vals eig_1 and eig_2
# The matrix of eigvecs is the rotation matrix generated by theta


class Darcy_nn(nn.Module):
    def __init__(self, input_size=3, hidden_size=64, output_size=1):
        super(Darcy_nn, self).__init__()
        self.fc1 = nn.Linear(input_size, hidden_size)
        self.fc2 = nn.Linear(hidden_size, hidden_size)
        self.fc3 = nn.Linear(hidden_size, hidden_size)
        self.fc4 = nn.Linear(hidden_size, hidden_size)
        self.fc5 = nn.Linear(hidden_size, hidden_size)
        self.fc6 = nn.Linear(hidden_size, output_size)
        self.activation = nn.GELU()

    def forward(self, x):
        x = self.activation(self.fc1(x))
        x = self.activation(self.fc2(x))
        x = self.activation(self.fc3(x))
        x = self.activation(self.fc4(x))
        x = self.activation(self.fc5(x))
        x = self.fc6(x)
        return x


@dataclass
class DatalessDarcyTrainingParams:
    h: float = 0.1
    Mesh: fe.Mesh = fe.UnitSquareMesh(10, 10)
    degree: int = 1
    f: str = "10"
    A_matrix_params: list[float] = field(default_factory=list)  # eig_1,eig_2,theta
    epochs: int = 10
    learn_rate: float = 0.001


def get_matrix_params_from(A: np.array) -> list:
    eig_vals, eig_vecs = np.linalg.eig(A)
    # When A is symmetric eig_vecs is a rotation matrix
    cos_theta = eig_vecs[0, 0]
    sin_theta = eig_vecs[1, 0]
    return [eig_vals[0], eig_vals[1], np.arctan2(sin_theta, cos_theta)]


class DatalessDarcy_nn_Factory:
    def __init__(self, params: DatalessDarcyTrainingParams):
        self.init_FEM_formulation(params)
        # if torch.cuda.is_available():
        #     device = torch.device("cuda")
        # else:
        #     device = torch.device("cpu")
        # self.u = (Darcy_nn(input_size=3, hidden_size=64, output_size=1).to(device),)
        # self.p = (Darcy_nn(input_size=3, hidden_size=64, output_size=1).to(device),)

        # self.u_optimizer = torch.optim.Adam(self.u.parameters(), lr=params.learn_rate)
        # self.p_optimizer = torch.optim.Adam(self.p.parameters(), lr=params.learn_rate)
        # self.lossfun = nn.MSELoss()
        # self.A_matrix_params = params.A_matrix_params
        # self.epochs = params.epochs
        # self.fit_nets = False

    def init_FEM_formlation(self, params: DatalessDarcyTrainingParams):
        self.Mesh = params.Mesh

    # def get_nets(
    #     self,
    # ):
    #     if self.fit:
    #         return self.sol

    # def fit(self, verbose: bool = False) -> None:
    #     self.fit = True
    #     for epoch in range(self.epochs):
    #         self.sol.u.train()
    #         self.sol.p.train()

    #         if verbose:
    #             print(f"Epoch: {epoch}, Action loss: {loss[0]} ")


if __name__ == "__main__":
    h = 0.25
    u_expression = (
        "5*x[1]*(1-x[1])*(1-2*x[0])+x[0]*(1-x[0])*(1-2*x[1])",
        "5*x[0]*(1-x[0])*(1-2*x[1])+x[1]*(1-x[1])*(1-2*x[0])",
    )
    p_expression = "x[0]*x[1]*(1-x[0])*(1-x[1])"

    exact_solution = [u_expression, p_expression]
    test_params = DatalessDarcyTrainingParams(
        h=h,
        Mesh=fe.UnitSquareMesh(
            round(1 / (h * np.sqrt(2))),
            round(1 / (h * np.sqrt(2))),
        ),
        degree=5,
        f="-10*x[1]*(1-x[1])-10*x[0]*(1-x[0])+2*(1-2*x[0])*(1-2*x[1])",
        A_matrix_params=get_matrix_params_from(np.array([[5, 1], [1, 5]])),
        epochs=10,
    )

    sol_factory = DatalessDarcy_nn_Factory(test_params)
    # sol_factory.fit(verbose=True)
    # sol = sol_factory.get_nets()
