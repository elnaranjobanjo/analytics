import fenics as fe
import json
import numpy as np
import torch
import os

import src.AI.nn_factory as nn_F
import src.formulations.formulation as F
import src.AI.neural_networks as nn


# Given a triplet [eig_1, eig_2, theta] the trainer class
# trains a pair of darcy nets u,p solving
#       -div u = f
#    A grad p = u
#           p = 0  b.c.
# with A sym. pos. def. with eigen vals eig_1 and eig_2
# The matrix of eigvecs is the rotation matrix generated by theta
class Darcy_dual_nn_factory(nn_F.nn_factory):
    def __init__(
        self,
        formulation_params: F.formulation_params,
        nn_params: nn.nn_params,
        training_params: nn_F.training_params,
    ):
        device = super().__init__(training_params)
        input_size = 4
        self.formulation = F.D.Darcy_dual_formulation(formulation_params)
        self.f = torch.from_numpy(self.formulation.get_rhs_vector())
        u_output_size = self.formulation.get_model_space().sub(0).dim()
        p_output_size = self.formulation.get_model_space().sub(1).dim()

        self.nn_solver = Darcy_dual_nn_solver().init_from_nets(
            {
                "u_net": nn.initialize_nn(input_size, u_output_size, nn_params).to(
                    device
                ),
                "p_net": nn.initialize_nn(input_size, p_output_size, nn_params).to(
                    device
                ),
            },
            self.formulation.get_model_space(),
        )

        self.define_optimizers(training_params.learn_rate)


# Given a triplet [eig_1, eig_2, theta] the trainer class
# trains a pair of darcy nets u,p solving
# Encodes the PDE loss func for:
#       -div A grad p = f
#           p = 0  b.c.
# with A sym. pos. def. with eigen vals eig_1 and eig_2
# The matrix of eigvecs is the rotation matrix generated by theta
class Darcy_primal_nn_factory(nn_F.nn_factory):
    def __init__(
        self,
        formulation_params: F.formulation_params,
        nn_params: nn.nn_params,
        training_params: nn_F.training_params,
    ):
        device = super().__init__(training_params)
        input_size = 4
        self.formulation = F.D.Darcy_primal_formulation(formulation_params)
        self.f = torch.from_numpy(self.formulation.get_rhs_vector())
        output_size = self.formulation.get_model_space().dim()

        self.nn_solver = Darcy_primal_nn_solver().init_from_nets(
            {
                "p_net": nn.initialize_nn(input_size, output_size, nn_params).to(
                    device
                ),
            },
            self.formulation.get_model_space(),
        )

        self.define_optimizers(training_params.learn_rate)


class Darcy_primal_nn_solver(nn_F.nn_solver):
    def __init__(self):
        super().__init__()
        pass

    def to_fenics(self, A_matrix_params: list) -> fe.Function:
        bias_term = torch.tensor([1], dtype=A_matrix_params.dtype)
        x_with_bias = torch.cat(
            (bias_term, torch.tensor(np.array(A_matrix_params))), dim=0
        )

        p_dofs = self.nets[0].forward(x_with_bias).detach().numpy()
        p = fe.Function(self.model_space)
        p.vector().set_local(p_dofs)
        return p

    def load(self, directory_path: str):
        degree, device = self.load_degree_and_device(directory_path)
        self.model_space = F.D.Darcy_primal_formulation(
            F.formulation_params(
                mesh_descr=os.path.join(directory_path, "mesh.xml"),
                degree=degree,
            )
        ).get_model_space()

        with open(
            os.path.join(directory_path, "p_net_nn_params.json"), "r"
        ) as json_file:
            p_params_json = json.load(json_file)

        self.nets = {
            "p_net": nn.initialize_nn(
                4, self.model_space.dim(), nn.make_nn_params_dataclass(p_params_json)
            ).to(device),
        }

        return self


class Darcy_dual_nn_solver(nn_F.nn_solver):
    def __init__(self):
        super().__init__()
        pass

    def init_from_nets(
        self,
        nets: dict,
        model_space: fe.FunctionSpace,
    ):
        self.nets = nets
        self.model_space = model_space
        return self

    def to_fenics(self, A_matrix_params: list) -> (fe.Function, fe.Function):
        bias_term = torch.tensor([1], dtype=A_matrix_params.dtype)
        x_with_bias = torch.cat(
            (bias_term, torch.tensor(np.array(A_matrix_params))), dim=0
        )
        u_dofs = self.u.forward(x_with_bias).detach().numpy()
        p_dofs = self.p.forward(x_with_bias).detach().numpy()

        (u, p) = fe.Function(self.model_space).split()

        u.vector().set_local(u_dofs)
        p.vector().set_local(p_dofs)
        return (u, p)

    def load(self, directory_path: str):
        degree, device = self.load_degree_and_device(directory_path)
        self.model_space = F.D.Darcy_dual_formulation(
            F.formulation_params(
                mesh_descr=os.path.join(directory_path, "mesh.xml"),
                degree=degree,
            )
        ).get_model_space()

        u_output_size = self.model_space.sub(0).dim()
        p_output_size = self.model_space.sub(1).dim()

        with open(
            os.path.join(directory_path, "u_net_nn_params.json"), "r"
        ) as json_file:
            u_params_json = json.load(json_file)

        with open(
            os.path.join(directory_path, "p_net_nn_params.json"), "r"
        ) as json_file:
            p_params_json = json.load(json_file)

        self.nets = {
            "u_net": nn.initialize_nn(
                4, u_output_size, nn.make_nn_params_dataclass(u_params_json)
            ).to(device),
            "p_net": nn.initialize_nn(
                4, p_output_size, nn.make_nn_params_dataclass(p_params_json)
            ).to(device),
        }

        return self
